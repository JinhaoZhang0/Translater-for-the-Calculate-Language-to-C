Assignment 3:  Translation
Your task in this assignment is to implement a complete (if simplistic) compiler for the extended version of the calculator language, again with if and while statements.  Your compiler (hereinafter referred to as the “translator”) will be written in OCaml and will generate C.  We are providing you with a parser generator and driver that build an explicit parse tree.  The provided code also includes the skeleton of a possible solution that converts the parse tree to a syntax tree and then recursively “walks” that tree to effect the translation.  You are of course welcome to adopt a different skeleton if you prefer.  Since this one has been excised from a complete working solution, however, you may find it a good place to start. 

The provided code has two main entry points:

  get_parse_table : grammar -> parse_table = ...
  parse : parse_table -> string -> parse_tree = ...
The first of these routines returns a parse table, in the format expected as the first argument of the second routine.  The second returns a parse tree.  (You’ll want to print some of these trees to see what they look like.)  If the program has syntax errors (according to the grammar), parse will print an error message (as a side effect) and return a PT_error value (it does not do error recovery).  If the input grammar you provide is malformed, you may get unhelpful run-time errors from the parser generator—it isn’t very robust. 
The grammar takes the form of a list of production sets, each of which is a pair containing the LHS symbol and k right-hand sides, each of which is itself a list of symbols.  When get_parse_table builds the parse table, the grammar is augmented with a start production that mentions an explicit end of file $$.  Later, parse will remove this production from the resulting parse tree.  The extended calculator language looks like this: 

  let ecg : grammar =
      [ ("P",  [["SL"]])
      ; ("SL", [["S"; "SL"]; []])
      ; ("S",  [ ["id"; ":="; "E"]; ["read"; "id"]; ["write"; "E"]
               ; ["if"; "C"; "SL"; "end"]; ["while"; "C"; "SL"; "end"]
               ])
      ; ("C",  [["E"; "rn"; "E"]])
      ; ("rn", [["="]; ["<>"]; ["<"]; [">"]; ["<="]; [">="]])
      ; ("E",  [["T"; "TT"]])
      ; ("T",  [["F"; "FT"]])
      ; ("TT", [["ao"; "T"; "TT"]; []])
      ; ("FT", [["mo"; "F"; "FT"]; []])
      ; ("ao", [["+"]; ["-"]])
      ; ("mo", [["*"]; ["/"]])
      ; ("F",  [["id"]; ["num"]; ["("; "E"; ")"]])
      ];;
A program is just a string: 

  let sum_ave_prog = "read a
    read b
    sum := a + b
    write sum
    write sum / 2";;
Your work will proceed in two steps: 

Translate the parse tree into a syntax tree: 
  let rec ast_ize_P (p:parse_tree) : ast_sl = ...
where the single argument is a parse tree generated by function parse.  We have provided a complete description of the ast_sl type, though you are free to modify this if you prefer a different format. 
Translate the AST into an equivalent program in C: 
  let rec translate (ast:ast_sl) : string * string = ...
where the argument is a syntax tree, as generated by function ast_ize_P and the return value is a tuple containing a pair of strings.  The first string, which will usually be empty, indicates (as a nicely-formatted, human-readable error message) information about variables that are assigned to (or read) but never used anywhere in the program, or used but never assigned to (or read) anywhere in the program.  This is as close as we get to static semantic error checking in this very tiny language.  The second string, which will usually be non-empty, comprises a complete C program equivalent to the original calculator program.  If fed to a C compiler, this program should compile with no compile-time errors, producing an executable that you can run from the command line. 
Putting the pieces together, the provided code includes the following: 
  let compile (code:string) (program_name:string) =
    try
      let (errs, output)
        = translate (ast_ize_P (parse ecg_parse_table code)) in
      let ofile_name = program_name ^ ".c" in
      let ofile = open_out ofile_name in
        output_string ofile output;
        close_out ofile;
        errs ^ "Code written to " ^ ofile_name ^ "\n"
    with Failure(msg) -> msg ^ "No code generated for " ^ program_name ^ "\n";;
This function accepts the code of a calculator program together with a name for that program, and writes its translation to a file that reflects the program name.  You should modify this code so that (when compiled with ocamlc and run as a stand-alone program), it takes the name of the program as a command-line argument, reads a single calculator program from a file with that name (plus a .calc suffix), and again writes it to a .c file. 
Your program should not take advantage of any imperative features.  You may read and write files and error messages as described above, and you can of course do whatever you want while debugging, but the main logic of your final syntax tree construction and translation routines should be purely functional. 

As noted in the previous assignment, the addition of if and while to the calculator language gives it significant computing power.  If we let primes_prog be a string containing the primes-generating program from that assignment (also included in the starter code) and then type

  print_string (snd (translate (ast_ize_P (parse ecg_parse_table primes_prog))));;
you should see, on standard output, a C program which, when compiled, run, and fed the input 10, prints
  2
  3
  5
  7
  11
  13
  17
  19
  23
  29
For the sake of convenience, we recommend that your output program always begin with definitions of two helper functions:

  #include <stdio.h>
  #include <stdlib.h>

  double getreal() {
    ... // returns a real number from standard input or
        // prints an appropriate error message and dies.
  }

  void putreal(double n) {
    ... // prints a real number and a linefeed to standard output.
  }
As noted above, your translator is required to print a warning if the input program assigns to or reads any variable that is never used.  (You do not have to notice if the program contains a use that will never be executed—only the lack of any use at all.)  Similarly, you are required to print a warning if the input program uses a variable that is never assigned to or read.  (This is a small, simple subset of the cases in which a program may use an uninitialized variable.) 

The C program you generate is required to catch the following dynamic errors, any of which will cause it to terminate early (with a helpful error message).  Note that some of these errors are not caught by default in C.  Your program will have to include extra code to catch them. 

unexpected end of input (attempt to read when there’s nothing there)
non-numeric input (the extended calculator language accepts only real numbers)
use of an uninitialized variable—one to which a value has not yet been assigned (read-ing counts as assignment). 
divide by zero (NB: C’s automatically generated “floating exception” is not very helpful: ideally you want something like “divide by zero at line 23”. You should write your code so that if you were tracking line numbers you could easily include the number in the message.  That is, you should not defer to C’s built-in handler; your generated code should check explicitly to make sure that denominators are not equal to zero.) 
Make sure you understand the interplay of static and dynamic errors.  At compile time, your translator must print a warning about any variable that is used but never assigned to anywhere in the program, or that is assigned to but never used anywhere in the program.  These are warnings only because (1) your translator can’t in general be sure whether the code that uses a never-assigned-to variable will actually be executed at run time, and (2) while assigning to a variable that you never use may be silly, it doesn’t really do any harm.

Then, at run time, the code produced by your translator must check for the error of using a variable to which a value has not yet been assigned.  Optionally, for extra credit, you can print a warning when a variable has been assigned a value and that value is not used before a new value is assigned or the program ends (such variables are not necessarily the same as those that were found, at compile time, to be assigned a value somewhere but never used anywhere). 

Hints
The initial source code is about 680 lines of OCaml.  You should read most of it carefully to understand how it works (you can skip the details of parse table construction if you like, though I think it’s kind of cool :-). 

For most of the assignment, it will probably be easiest to use the ocaml interpreter.  You’ll want to keep reloading your source code (#use "translator.ml") as you go along, so you catch syntax and type errors early.  On occasion, you may also want to try compiling your program with ocamlc, to create a stand-alone executable.  Note that the code we have given you uses functions (regexp and split) from the Str library.  This library is not visible to either the interpreter or the compiler by default.  In ocaml, you will need to say

  #load "str.cma";;
before you #use your source code.  (Once is enough; you don’t have to re-#load in order to re-#use.)  With ocamlc, type the following at a shell prompt:
  ocamlc str.cma translator.ml
We have provided code for the sum-and-average and primes-generating calculator programs.  You will undoubtedly want to write more for purposes of debugging. 

We will be grading your assignment using /usr/bin/ocamlc on the csug machines.  You can download your own copy for Windows, MacOS, or Linux, but please be sure to check that your code works correctly on the csug installation. 

My (not necessarily great) implementation of the full set of ast_ize_ functions is about 50 lines of code.  My version of the full set of translate_ functions is about 100 lines, plus about 35 lines of prologue to go at the top of every generated C program. 

You may find the following helpful. 

OCaml system documentation.—includes the language definition; manuals for the interpreter, compilers, and debugger; standard library references; and other resources. 
Tutorials on various aspects of the language. 
OCaml for the Skeptical— an alternative, arguably more accessible introduction to the language from the University of Chicago. 
Developing Applications with Objective Caml— a book-length online introduction to functional programming and everything OCaml. 
Division of labor and writeup
As in most assignments this semester, you may work alone or in teams of two.  If you choose to work in pairs, I strongly encourage you to read each others’ code, to make sure you have a full understanding of semantic analysis.  The most obvious division of labor is for one team member to write ast_ize_P and the other to write translate, but other divisions are fine as well. 

Be sure to follow all the rules on the Grading page.  As with all assignments, use the turn-in script:  ~cs254/bin/TURN_IN.  Put your write-up in a README.txt or README.pdf file in the directory in which you run the script (only one README required per team).  Be sure to describe any features of your code that the TAs might not immediately notice. 

Extra Credit Suggestions
Extend the calculator grammar in other interesting ways.  You might, for example, implement separate integer and floating-point types, arrays, for loops, nested scopes, or functions.  Several of these are likely to introduce rules that you will want to check statically. 
Write code to interpret the AST directly on a given input, rather than (or as an alternative to) translating to C. 
Generate warning messages when a variable is assigned a value but the previous value has not yet been used—or when the program ends and a variable contains a value that has not yet been used.  Discuss in your README whether such warnings are helpful. 
Track the location (line, column) of tokens in the calculator program so you can generate better semantic error messages (both static and dynamic). 
Add syntax error recovery. 